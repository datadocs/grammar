# Syntax

This document is to provide a description of the Types, Operators, and Syntax that is used in Datadocs SQL. The implementation is based upon [DuckDB](https://duckdb.org/docs/sql/data_types/overview) (whose grammar is based on Postgres), however there are some departures and simplifications that we make along the way.

Note that this page is primarily concerned with data type and expression  syntax and not with the overall SQL statement syntax, in other words, what is valid in the form of `SELECT <expr>`. <br/><br/>

## Identifiers

Identifiers are names associated with databases, schemas, tables, columns, struct sub-fields, and aliases of a table or column. They must be in the "standard variable" form of `[_A-Za-z][_A-Za-z0-9]+` and cannot conflict with reserved words; or they must be quoted with backticks, such as ``` `my Column 1` ```. Escape sequences are introduced with a backslash (`\`), and a list of recognized escape sequences can be found at the [BigQuery Syntax page](https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#string_and_bytes_literals), excluding the last entry. The length of an identifier must be between 1 and 64 characters.

A "path expression" describes how to navigate to or within a certain object, and contains multiple identifiers separated by a `.` (or a `[]` if navigating within an Array in a column or sub-field). Examples of path expressions include: `Table.Field` `StructField.subField`, ```table.`my arrayField`[0].subField```, `foo().dataField[2].subField`. 

Important things to note here are:

1. There may be potential ambiguity in a path expression. For example `identifier1`.`identifier2` could resolve to Table.Field, or Struct.SubField.  `identifier1`.`identifier2`.`identifier3` could resolve to Schema.Table.Field or Table.Field.SubField or Field.SubField1.SubField2. If it is ambiguos -- meaning a name or path could potentially resolve to multiple objects -- we can raise a warning.
2. We will use backtick quoting for identifiers and single- or double-quotes for string/bytes literals, similar to [BigQuery](https://cloud.google.com/bigquery/docs/reference/standard-sql/lexical#identifiers) or MySQL. Note that this is not the Postgres or DuckDB default.
3. Datadocs SQL may be transpiled to backends that do not always have the same object hierarchy. For example, Postgres uses [Databases].[Schema].[Table].[Field], but MySQL uses only [Database].[Table].[Field]. This means that an object-path that refers to a database object requires the backend to be known to be semantically verified.<br/><br/>




## Types

The following are the Datadocs general-purpose types:

| Type     	| Literal                                                                  	| Aliases                	| Notes                                                                                                                                                             	|
|----------	|--------------------------------------------------------------------------	|------------------------	|-------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| --       	| `null`                                                                   	|                        	|                                                                                                                                                                   	|
| BOOL     	| `true`, `false`                                                          	| BOOLEAN                	|                                                                                                                                                                   	|
| INT<sup>1</sup>       	| `4`                                                                      	| INTEGER            	| `[+-]?[0-9]+`, no hex or alternate formats.                                                                                                                       	|
| FLOAT<sup>1</sup>     	| `4.2`, `123.456e-67`, `58.`, `4e2`,  `'NaN'::Float`                      	| REAL       	| `[+-]DIGITS.[DIGITS][e[+-]DIGITS]`, `DIGITSe[+-]DIGITS`  or `[DIGITS].DIGITS[e[+-]DIGITS]`. The strings 'NaN',  'inf', '+inf', '-inf' may also be cast to floats. 	|
| DECIMAL  	| `DECIMAL(3,2) '1.2'`, `DECIMAL '2'`                                      	| NUMERIC                	| Requires a valid float as a string.                                                                                                                               	|
| STRING   	| `"Hello"`, `'Hello'`, `'it\'s'`                                          	| VARCHAR, TEXT          	| Single or double quoted string. May include escapes.                                                                                                              	|
| BYTES    	| `b'aMc12'`, `B"abc"`                                                     	| BINARY, BLOB    	| Single or double quoted, prefixed with `b` or `B`.                                                                                                                	|
| DATE    	| `DATE '2014-01-01'`, `DATE '0000-01-01'`                                 	|                        	| `DATE 'YYYY-M[M]-D[D]'` from 0000-01-01 to 9999-12-31                                                                                                             	|
| TIME     	| `TIME '12:30:00'`, `TIME '12:30:00.45'`                                  	|                        	| `TIME '[H]H:[M]M:[S]S[.DDDDDD]'`                                                                                                                                  	|
| DATETIME<sup>2</sup>  	| `DATETIME '1992-09-20 11:30:00'`, `DATETIME '1992-09-20T11:30:00-02:00'` 	| TIMESTAMP 	| `DATETIME 'YYYY-[M]M-[D]D[ tT][[H]H:[M]M:[S]S[.DDDDDD]]'` A timezone `(+\|-)H[H][:M[M]]`, may be supplied.                                                        	|
| INTERVAL 	| `INTERVAL 2 hour`, `INTERVAL '2' second`                                 	|                        	| Number will be cast to integer. Valid interval units are  `YEAR`, `MONTH`, `DAY`, `HOUR`, `MINUTE`, `SECOND` (both singular or plural accepted).                                                     	|

<sup>1</sup>*The width of the integral or floating point type is an implementation detail **unless explicitly set** by the user. For example, a user may explicitly specify that the type is a `uint16`, or the system may infer based on the provided data that it can be stored in a smaller-than-eight-byte width.*

<sup>2</sup>*The `DATETIME` type will be stored with timezone UTC. If a timezone is provided, it will be converted to UTC before being inserted. For example, `DATETIME '2014-09-27T12:30:00+03:30'` would be stored or parsed as `2014-09-27 09:00:00`.*


<br/>

In addition to general-purpose types, Datadocs also supports the following:

| **Type** 	| **Literal**                                   	| **Aliases** 	| **Notes**                                                                                                                                                                                                                                                                                                                                                                                                                                                              	|
|----------	|-----------------------------------------------	|-------------	|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| GEO      	| `POINT '(1,1)'`, `LINE '((1,1),(2,2))'`       	| GEOGRAPHY   	| Not currently supported in DuckDB, see [here](https://github.com/duckdb/duckdb/issues/4118) as the first part of its implementation. Supported types: `POINT`, `LINE`, `POLYGON`, `MULTI[POINT\|LINE\|STRING]`, and `GEOMETRYCOLLECTION`. See BigQuery's [GEO type](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-types#geography_type) for details.                                                                                              	|
| JSON     	| `JSON '{"first": 2}'`, `JSON '[1, "two", 3]'` 	|             	| Literal may be directly accessed, such as `JSON '[1,2,3]'[1]` or `JSON '{"day": "Monday"}'.day`. Note: DuckDB requires including its json extension, and the above differs from its standard access syntax.                                                                                                                                                                                                                                                          	|
| STRUCT     	| `{"birthday": DATE '2014-01-01'`}, (1,2,3)            	|             	| Note that this uses DuckDB [struct syntax](https://duckdb.org/docs/sql/data_types/struct). Can also be accessed directly, similar to `JSON` type. Must have unique keys. Note the short-hand tuple-like form of the struct, creating anonymous fields. This is used primarily for the `IN (...)` operator.                                                                                                                                                                                                                                                                                    	|
| VARIANT    	| 2::VARIANT                            	|             	| `VARIANT` is a data container that will allow any other type within it, as such the literals are the same as for any other types, and there is not specific literal value for a `VARIANT`. It does not support a `STRUCT`, and if provided will be decayed to a `JSON` type. For example, in a `VARIANT` column, the struct `{"d": DATE '2014-01-01'}` would decay to `JSON '{"d": "2014-01-01"}'`.                                                                                                                                   	|
| ARRAY      	| `[1, 2, 3]`                                   	|             	| `ARRAY` allows us to specify whether a data type is repeated or not, and is a property on the base data type, `IsRepeated`. It only supports a homogenous type, does not allow `null` elements, and does not allow arrays-of-arrays. As such, if any of these limitations are encountered, we will demote it to `VARIANT[]`. For example, `[1,null,2]`, `[1,2,"a"]` and `[[1,1],[2,2]]` would all be stored as `VARIANT[]`. **The array should be annotated in the parse tree to specify whether it has any of these limitations (mixed-type, null, multiple-arrays)**.


We will also have a `ROW` and `TABLE` type, but these type will not be covered here, as they are not a scalar-type. They can be ignored for now.<br/>



**Spreadsheet parsing helpers**: In addition to entering a query, a user may also use the Datadocs spreadsheet interface to enter in values directly into a cell. If the first character entered is either `=`, `-`, or `+`, it will evaluate it as an expression -- such as that encountered by `SELECT <expr>` -- otherwise it will be interpreted as a literal. *Note that when someone enters in `=<exp>` to a spredsheet cell, it will be interpreted **exactly** as if it were entered into a `SELECT` list of a SQL statement without a `FROM` clause (though the resultant value may be cast to a `VARIANT` type when entered in a spreadsheet cell).*

As an example when entered directly into a spreadsheet cell, `=1+1` will evaluate to the integer `2`, whereas entering in `1+1` would evaluate to the string `1+1`. Similarly, `="hello"` would evaluate to the string `hello` with length five, whereas `"hello"` would evaluate to the string `"hello"` with length seven.

Here are some important notes: 

1) Numeric formatters such as `%`, `,`, and `$` (or other currencies) need to be handled accordingly. For example, `12.2%` would be parsed as `0.122` and `1,000` would be parsed as `1000`. **The parser must preserve these formatters for downstream access**. For example `12.2%` might be parsed as: `{"value": "0.122", "type": "float", "_meta": {"includesPercent": true, "includesCommaSeparators": false, "currencySymbol": null}}`

2) Common date, time, and datetime conversions are automatically handled on input. For example all of `jan 1, 2014`, `january 1, 2014`, `2014-01-01`, `1/1/2014` and `1-1-2014` would be parsed as the same date, `DATE '2014-01-01'`. Note that `2014-30-30` would not be parsed as a date.

3. Unless a special case is found, a string is assumed. For example if I edit a cell and type in `Hello`, it will parse that as the string `"Hello"`. 

    A user may also force a string literal by entering in `'` (apostrope) as the first character, such as `'2014-01-01`. Note that the leading `'` is stripped for display, and so entering in `'hello'` will be displayed as `hello'`. Typing in `'2014-01-01` would display `2014-01-01` but then if edited again will show `'2014-01-01` so that it doesn't get re-parsed as a date.

4. Whatever value is supplied or evaluated to will be cast to the specific type of the column, or `VARIANT` if unspecified.
<br/><br/>

**It is important to note that entering a literal into a Spreadsheet cell is not the same as entering in a literal into a query.** This should be obvious but it is important to point out. Entering in `SELECT 10%` is invalid when entered in a query, but entering in `10%` directly into a cell would interpret that as the number `0.01`.

While the expression syntax within a spreadsheet cell is the same as that evaluated within a `SELECT` expression, entering literals is not and additional tests will need to test to make sure Literal Parsing within spredsheet cells is correct.<br/><br/>

## Operators

The following are a list of operators recognized by Datadocs. All operators have binary arity unless stated explicitly in the operator.


| **Precedence** 	| **Operator**                                           	| **Input Types**                                                             	| **Examples**                                                                                                                                                                               	| **Notes**                                                                                                                                                                                                                                                                                                                                                                                                                                                                     	|
|----------------	|--------------------------------------------------------	|-----------------------------------------------------------------------------	|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| 1              	| `.`  _(object access)_                                 	| JSON, STRUCT                                                                	| `JSON '{"x": 4}'.x`, <br/> ``` JSON '{"x": 4}'.`x` ```, <br/>`{age: 4}.age`, <br/>```{"my age": 10}.`my age` ```                                                                           	| Invalid key will produce a `null` value for `JSON` type and an invalid field error for `STRUCT`. This works "as if" it is a field access, and so the identifier of the data object may be quoted with ``` ` ```.<br/>Keys of a `STRUCT` must be non-empty unique strings, and may be unquoted if a valid identifier.                                                                                                                                                        	|
|                	| `[int]`, `[int:int]`, `[key]`,  _(subscript operator)_ 	| JSON, ARRAY                                                                 	| `JSON '[1,2,3]'[0]`, <br/> `[1,2,3][1:2]`, <br/> `[1,2,3][-1]`, <br/> `JSON '{"ok!": [1,2,3]}'['ok!'][0]`                                                                                  	| Invalid subscript will produce a `null` value for `JSON` type and an index error for `STRUCT`.<br/> JSON may have an object accessed by `obj.key` as well as by `obj[key]`. <br/> Both native and javascript arrays may be accessed with slice notation (`arr[1:2]`)or negative indexes (`arr[-1]`).                                                                                                                                                                          	|
| 2              	| `+`, `-` _(unary plus, minus)_                         	| Numeric types                                                               	| `+2`, `++2`, `+-+--2`                                                                                                                                                                      	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
|                	| `~` _(unary bitwise not)_                              	| INTEGER, BYTES                                                              	| `~1`, `~~1`, `~b'hi'`, `~~b'hi'`                                                                                                                                                           	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 3              	| `*`, `/` _(multiplication, division)_                  	| Numeric types                                                               	| `2*2/3`                                                                                                                                                                                    	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
|                	| `\|\|` _(concatenation)_                               	| STRING, BYTES                                                               	| `TRUE \|\| 1 \|\| 1.2 \|\| DECIMAL '1.2' \|\| 'a' \|\| DATE '2014-01-01' \|\|  TIME '12:12:12' \|\| DATETIME '1992-01-01 01:02:03' \|\| INTERVAL 2 hour`, <br/> `b'hi' \|\| b'123'`, <br/> 	| `STRING` cast will support anything that can be cast to a string. <br/> This translates to all of the general-purpose data types except `BYTES`.                                                                                                                                                                                                                                                                                                                              	|
| 4              	| `+`, `-` _(addition, subtraction)_                     	| Numeric+Numeric, INTERVAL+INTERVAL, DATE\|TIME\|DATETIME+INTERVAL\|INTERVAL 	| `1-1`, `INTERVAL 2 hour + INTERVAL '4' second`, `DATE '2014-01-01' - 2`,  `DATE '2014-01-01' - INTERVAL 1 month`                                                                           	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 5              	| `<<`, `>>` _(bitwise left-, right-shift)_              	| INTEGER\|BYTES+INTEGER                                                      	| `2<<2`, `b'12'<< 2 >> 1`                                                                                                                                                                   	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 6              	| `&` _(bitwise and)_                                    	| INTEGER, BYTES                                                              	| `2&2`, `b'12'&b'12'`                                                                                                                                                                       	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 7              	| `^` _(bitwise xor)_                                    	| INTEGER, BYTES                                                              	| `2^2`, `b'12'^b'12'`                                                                                                                                                                       	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 8              	| `\|` _(bitwise or)_                                    	| INTEGER, BYTES                                                              	| `2\|2`, `b'12'\|b'12'`                                                                                                                                                                     	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 9              	| `=`, `!=`, `<>` _(equals, not equals)_                 	| All types, with exceptions (see note)                                       	| `2=2.0`, `'x' = 'x'`, `1.2 = 2`, `2!=2`, `2<>2`                                                                                                                                          	| We will allow comparisons when (1) the two operands are the same type, or (2) a `VARIANT` is one of the types (discussed separately). `ARRAY`, `GEO`, `JSON`, and `STRUCT` will not allow for direct comparison. However, all of these do have a `toString()` method and so can be compared in the interface with this.	|
|                	| `<`, `<=`, `>`, `>=` _(comparisons)_                   	| All types, with exceptions (see note)                                       	| `2<2`, `2>=5`,                                                                                                                                                                             	| See note above.                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
|                	| `[NOT] BETWEEN` _([not] between)_                      	| All types, with exceptions (see note)                                       	| `2 BETWEEN 0 and 3`                                                                                                                                                                        	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
|                	| `[NOT] IN` _([not] in)_                                	| All types, with exceptions (see note)                                       	| `(1,2) IN ((1,2),(3,4))`, `'hi' IN ('hi', 'bye')`                                                                                                                                          	| This is basically an equality check to check against multiple candidates at once, so `x in (a,b,c)` essentially translates to `x=a or x=b or x=c`. See above note about equality comparisons.                                                                                                                                                                                                                                                                                 	|
|                	| `[NOT] LIKE` _([not] like)_                            	| STRING                                                                      	| `'hi' like 'h%'`                                                                                                                                                                  	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
|                	| `IS [NOT] NULL` _(unary [not] null)_                   	| All types                                                                   	| `2 is null`                                                                                                                                                                                	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 10             	| `NOT` _(unary logical not)_                            	| BOOL                                                                        	| `NOT 1=1`, `NOT true`                                                                                                                                                                      	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 11             	| `AND` _(logical and)_                                  	| BOOL                                                                        	| `1=1 AND 2=2`                                                                                                                                                                              	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|
| 12             	| `OR` _(logical or)_                                    	| BOOL                                                                        	| `1=2 OR 3=3`                                                                                                                                                                               	|                                                                                                                                                                                                                                                                                                                                                                                                                                                                               	|

<br/><br/>

## Expressions

Expressions covered here include `CASE`, `CAST`, `COLLATE`, Function Calls,  Aggregate Calls, Window Calls, and Subqueries. Certain additional functions behave more like expressions and are short-circuited before evaluating all parameters, such as `COALESCE`. Those will still be covered under the function table with a note indicating so. Additional expression operators are covered in the [Operators](#operators) section above.<br/>

| **Expression**  	| **Syntax**                                                                                                    	| **Examples**                                                                                        	| **Notes**                                                                                                                                                                                                                                                                                                                                                                                                                           	|
|-----------------	|---------------------------------------------------------------------------------------------------------------	|-----------------------------------------------------------------------------------------------------	|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|
| Case            	| `CASE WHEN predicate THEN result`<br/>       `[...]`<br/>       `[ELSE else_result]`<br/> `END`               	| `CASE WHEN 2>1 THEN 3 END`                                                                          	| Some databases require that all potential results of a `CASE` have the same coercible type.<br/> For example, `CASE WHEN 1>0 THEN 'a' ELSE 0 END` would fail on BigQuery, Postgres, and Oracle.<br/> **We will also enforce strict type checking on the output values.**<br/>                                  	|
| Cast            	| `CAST(exp AS type)`, `exp::type`                                                                              	| `'1.2'::DECIMAL(3,2)`, `CAST('1.2' AS DECIMAL(3,2))`                                                	| Note we allow the `::` operator here.                                                                                                                                                                                                                                                                                                                                                                                               	|
| Scalar Subquery 	| `(select-node)`                                                                                               	| `SELECT (SELECT 1)`                                                                                 	| Without a `FROM` clause a sub-select is trivial,<br/> but let's make sure that we have it accounted for in the grammar.                                                                                                                                                                                                                                                                                                             	|
| Collation       	| `COLLATE {YES\|NO}CASE`                                                                                                    	| `colA LIKE 'a%' COLLATE NOCASE`                                                                         	| See the [case-sensitivity](#case-sensitivity) note above for more details.                                                                                                                                                                                                              	|
| Function calls  	| `function_name([expression [, expression ... ]] )`                                                            	| `ABS(1)`                                                                                            	| We will not support named arguments. Note that some functions may have a non-standard syntax,<br/> such as `extract(param1 FROM param2)`. Whenever these are encountered they will be explicitly called out.                                                                                                                                                                                                                        	|
| Aggregate calls 	| `aggregate_name (*)`,<br/> `aggregate_name([DISTINCT] expression [, ...] [ORDER BY sort_expression, [, ...])` 	| `MIN(x)`, <br/> `ARRAY_AGG(DISTINCT fruit ORDER BY fruit ASC)`<br/> `STRING_AGG(a, ',' ORDER BY a)` 	| Most aggregate function calls will have a single parameter and not allow an `ORDER BY`.<br/> Some backends do not support `ORDER BY`. Other backends support three additional constructs:<br/> `LIMIT`, `FILTER` and `IGNORE\|RESPECT NULL` We will not support these to start.                                                                                                                                                     	|
| Window calls    	| aggregate_call `OVER (named_window\|window_expression)`                                                       	| `LAST_VALUE(purchase) OVER (ORDER BY date)`<br/>                                                    	| This is a huge simplification, though its grammar should already be defined in the DuckDB syntax. A full listing of the syntax can be found [here](https://duckdb.org/docs/sql/window_functions) and for other examples [see BQ here](https://cloud.google.com/bigquery/docs/reference/standard-sql/window-function-calls) and [see PG here](https://www.postgresql.org/docs/current/sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS)  	|



<br/><br/>

## Functions


The following are a sample of supported functions by Datadocs. The full function list may be viewed at the [DuckDB Functions page](https://duckdb.org/docs/sql/functions/overview). All functions are scalar. They may also be viewed programmatically by executing `select distinct on(function_name) * from duckdb_functions();` in the [DuckDB shell](https://shell.duckdb.org/). A more descriptive one-page reference which covers most of the functions can be found [here from BQ](https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators).


| **Category** 	| **Function**                                                 	| **Description**                                                                                                                                                                                                                                                                                                                                                                                                      	| **Example (result)**                                                   	|
|--------------	|--------------------------------------------------------------	|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------	|------------------------------------------------------------------------	|
| Math         	| `ABS(x)`                                                     	| Computes the absolute value.                                                                                                                                                                                                                                                                                                                                                                                         	| `ABS(-4)` (4)                                                          	|
|              	| `GREATEST(X1,...,XN)`                                        	| Finds the largest value.                                                                                                                                                                                                                                                                                                                                                                                             	| `GREATEST(2,1)` (2), `GREATEST('a','b')` ('b')                         	|
|              	| `RAND()`                                                     	| Generates a random float between 0 and 1.                                                                                                                                                                                                                                                                                                                                                                            	| `RAND()` (0.473)                                                       	|
| Text         	| `UPPER(value)`                                               	| Converts all characters to uppercase.                                                                                                                                                                                                                                                                                                                                                                                	| `UPPER('hi')` ("HI")                                                   	|
|              	| `CONCAT_WS(separator, value, [,...])`                        	| Concatenate strings together separated by the separator.                                                                                                                                                                                                                                                                                                                                                             	| `CONCAT_WS('-', '1', '2)` ("1-2")                                      	|
|              	| `REGEXP_REPLACE(value, regexp, replacement)`                 	| Replaces occurrences of the regexp pattern in the value string  with replacement string. Note that regex support can differ quite drastically between databases and browsers. For now, we will use the in-built JS/browser regex to verify the regex. Eventually we can store properties about the regex and see which of those are supported by the backend (such as backtracking, certain character classes, etc.) 	| `REGEXP_REPLACE('hello', '[lo]', '-')` ('he-lo')                       	|
|              	| `PRINTF(format, parameters...)`                              	| Formats a string using printf syntax.<br/> Will require an external library such as https://github.com/alexei/sprintf.js.                                                                                                                                                                                                                                                                                            	| `printf('"%s" took %d seconds', 'CSV', 42)` ("CSV" took 42 seconds)    	|
| Date         	| `CURRENT_DATE()`                                             	| Returns the current date in UTC.<br/> In DuckDB must be called with schema qualifier, such as `main.current_date()` or `current_date` (no parens).                                                                                                                                                                                                                                                                   	| `current_date()` (DATE 2022-08-05)                                     	|
|              	| `DATE_DIFF(date_part, date_expression_a, date_expression_b)` 	| Difference between two dates in specified time unit.                                                                                                                                                                                                                                                                                                                                                                 	| `DATE_DIFF('MONTH', DATE '2010-07-07', DATE '2008-12-25', DAY)` (-19)  	|
| Datetime     	| `EXTRACT(date_part FROM timestamp)`                          	| Extract specified part from a supplied datetime_expression.<br/> Note that this function uses non-standard syntax, allowing for a `FROM` keyword within the function call.                                                                                                                                                                                                                                           	| `EXTRACT('day' FROM TIMESTAMP '1992-09-20 20:38:48')` (20)             	|
|              	| `NOW()`                                                      	| Get current date and time.                                                                                                                                                                                                                                                                                                                                                                                           	| `NOW()` (DATETIME 2022-08-07 01:51:50.284)                             	|
| Time         	| `CURRENT_TIME()`                                             	| Get current time.                                                                                                                                                                                                                                                                                                                                                                                                    	| `CURRENT_TIME()` (TIME 15:31:38.776361)                                	|
|              	| `EXTRACT(part FROM time)`                                    	| Extract part from supplied time. Defined only for `hours`,  `minutes`, `seconds`, `milliseconds` and `microseconds`.                                                                                                                                                                                                                                                                                                 	| `EXTRACT('hour'FROM TIME "15:30:00")` (15)                             	|
| Interval     	| `EXTRACT(part FROM interval)`                                	| Extract relevant part from an interval.                                                                                                                                                                                                                                                                                                                                                                              	| `EXTRACT('month' FROM INTERVAL '14 months')` (2)                       	|
| Bytes        	| `OCTET_LENGTH(value)`                                        	| Number of bytes in blob.                                                                                                                                                                                                                                                                                                                                                                                             	| `OCTET_LENGTH('\xAABB'::BLOB)` (2)                                     	|
| Array        	| `LIST_CONCAT(list1, list2)`                                  	| Concatenates two lists.                                                                                                                                                                                                                                                                                                                                                                                              	| `LIST_CONCAT([2, 3], [4, 5, 6])` ([2, 3, 4, 5, 6])                     	|
|              	| `ARRAY_LENGTH(list)`                                         	| Return the length of the list.                                                                                                                                                                                                                                                                                                                                                                                       	| `ARRAY_LENGTH([1, 2, 3])` (3)                                          	|
| Struct       	| `TO_JSON(value)`                                             	| Takes any value and returns its JSON string representation.<br/> This is not really a `STRUCT` function (and a struct itself does not have any unique functions for it, but this is a good way to test a struct).<br/> Requires the [JSON extensions](https://duckdb.org/docs/extensions/json) in DuckDB.                                                                                                            	| `TO_JSON({X : 100}` ('{"X": 100}')                                     	|
| JSON         	| `JSON_EXTRACT(value, path)`                                  	| Extract `JSON` from a json-object at the given path.<br/> Requires the [JSON extensions](https://duckdb.org/docs/extensions/json) in DuckDB                                                                                                                                                                                                                                                                          	| `JSON_EXTRACT(JSON '{"family": "anatidae", '$.family')` ('"anatidae"') 	|
| GEO          	| `ST_X(point)`                                                	| Returns the longitude in degrees of the single-point input `GEOGRAPHY`.<br/> This is a trivial function and only works on points, but we will implement it  as a way to at least show that `GEO POINT` literals are working. Full example [here](https://cloud.google.com/bigquery/docs/reference/standard-sql/geography_functions#st_x).                                                                            	| `ST_X(POINT '(0 1)') (0)`                                              	|
| VARIANT      	| `2::VARIANT + 2`                          	| In this example, it should cast the `2::VARIANT` to a number since the other operand to the binary operation is a number.                                                                                                                                                               	|                                                                        	|
| Aggregate    	| `COUNT`                                                      	| Grabs a count for all non-null entries in output.                                                                                                                                                                                                                                                                                                                                                                    	| `COUNT(0)` (1), `COUNT(null)` (0)                                      	|
| Window       	| `ROW_NUMBER()`                                               	| The number of the current row within the partition, counting from 1. With a single row it will always return 1.                                                                                                                                                                                                                                                                                                      	| `ROW_NUMBER() OVER (PARTITION BY 'x' ORDER BY 2)` (1)                  	|
| Utility      	| `COALESCE(expr[, ...]`                                       	| Returns the first non-null element.                                                                                                                                                                                                                                                                                                                                                                                  	| `COALESCE(NULL 'a', 1)` ('a')                                          	|
| Special      	| `XL.SUM(val1, val2, ...)`                                    	| This is an emulation of how the Excel `SUM` function works, summing numeric values<br/> and ignoring non-numeric values. Note each expression param is evaluated 'normally'<br/> before it is determined whether it is numeric or not, so errors may occur before<br/> the actual summing is done.                                                                                                                   	| `XL.SUM(1+1,2,'a',3)` (7)                                              	|
|              	| `XL.TEXT(value, format)`                                     	| This is a replication of the Excel `TEXT` function  [here](https://support.microsoft.com/en-us/office/text-function-20d5ac4d-7b94-49fd-bb38-93d29371225c).<br/> This library will be invoked directly here and you won't have to write any of it.                                                                                                                                                                    	| `TEXT(0.285,"0.0%")` ('28.5%')                                         	|
|              	| `DD.TRANSLATE(text, src_lang, dest_lang)`                                     	| This is a sample function that we will not implement and will be used to show a function that cannot be previewed. However, we should verify that the params are correct.                                                                                                                                                                    	| `DD.TRANSLATE("Hello","en", "fr")` ('No preview available')                                         	|

<br/><br/>



## Other Syntax notes

1. Case sensitivity is generally unimportant, excluding strings. For example, Keywords, Functions, Object Names and Aliases. `SELECT * FROM TABLE AS E` is the same as `select * from table as e`. Note however that some databases will allow case-sensitive tables (BigQuery being one example). For example, the query `SELECT * FROM a` would return something different than `SELECT * FROM A`, as `a` and `A` are different tables. This means that if an identifier lookup returns two objects that differ only in casing, we must choose the one with the exact case.

2. <a id="case-sensitivity"></a>Case-sensitivity in strings is a non-trivial matter, as many databases handle this differently: for example, by default MySQL, SQLite, SQLServer are case-insensitive, and Oracle, Postgres, BigQuery and ANSI-SQL are case-sensitive. Case-sensitivity affects many things involving comparison, many of which occur behind-the-scenes, for example if we have the string columns `strCol1`, `strCol2`: `'a' = 'A'`, `strCol1 = 'A'`, `strCol1 LIKE 'A%'`, `'x' LIKE '%X%'`,  `strCol1 > 'a'`, `GREATEST(strCol1, srCol2)`, `ORDER BY strCol1`, `MAX(strCol1)`, `tbl1 JOIN tbl2 USING (strCol1)` `GROUP BY strCol1`, and even [more here](https://cloud.google.com/bigquery/docs/reference/standard-sql/collation-concepts#collate_operations). In other words, directly executing `SELECT 'a' = 'A'` will return `true` on MySQL, but `false` on Postgres, and a filter or aggregate, if using the incorrect case, might take 100x longer. And then we may join tables in two different databases that have different case-sensitivity. 

    This quite a complex subject, but at the parsing/syntax stage we can have the following two items to cover this:

    a) Having an application default, which will be case-insensitive on any expression evaluations that we do in javascript.

    b) Allowing to explicitly specific a `COLLATE [NO|YES]CASE` for an expression, which would allow the application to override the default behavior whenever necessary (and possible).

3. Single-line comments may be in-lined with by prepending `--` or `#` on that line. Comments may also be enclosed with `/*  */` and may span multiple lines.

4. Regarding Reserved Keywords, we can defer to the existing antlr grammar, but the following may be used as a starting list: 

    `ALL`, `AND`, `ANY`, `ARRAY`, `AS`, `ASC`, `ASYMMETRIC`, `AT`, `BETWEEN`, `BOTH`, `BY`, `CASE`, `CAST`, `CHECK`, `COLLATE`, `COLUMN`, `CONSTRAINT`, `CONTAINS`, `CREATE`, `CROSS`, `CUBE`, `CURRENT`, `CURRENT_CATALOG`, `CURRENT_DATE`, `CURRENT_ROLE`, `CURRENT_TIME`, `CURRENT_TIMESTAMP`, `CURRENT_USER`, `DEFAULT`, `DEFERRABLE`, `DEFINE`, `DESC`, `DISTINCT`, `DO`, `ELSE`, `END`, `ENUM`, `ESCAPE`, `EXCEPT`, `EXCLUDE`, `EXISTS`, `EXTRACT`, `FETCH`, `FOLLOWING`, `FOR`, `FOREIGN`, `FROM`, `FULL`, `GRANT`, `GROUP`, `GROUPING`, `GROUPS`, `HASH`, `HAVING`, `IF`, `IGNORE`, `IN`, `INITIALLY`, `INNER`, `INTERSECT`, `INTERVAL`, `INTO`, `IS`, `JOIN`, `LATERAL`, `LEADING`, `LEFT`, `LIKE`, `LIMIT`, `LOCALTIME`, `LOCALTIMESTAMP`, `LOOKUP`, `MERGE`, `NATURAL`, `NEW`, `NO`, `NOT`, `NULL`, `NULLS`, `OF`, `OFFSET`, `ON`, `ONLY`, `OR`, `ORDER`, `OUTER`, `OVER`, `PARTITION`, `PLACING`, `PRECEDING`, `PRIMARY`, `PROTO`, `QUALIFY`, `RANGE`, `RECURSIVE`, `REFERENCES`, `RESPECT`, `RETURNING`, `RIGHT`, `ROLLUP`, `ROWS`, `SELECT`, `SESSION_USER`, `SET`, `SOME`, `STRUCT`, `SYMMETRIC`, `TABLE`, `TABLESAMPLE`, `THEN`, `TO`, `TRAILING`, `TREAT`, `UNBOUNDED`, `UNION`, `UNIQUE`, `UNNEST`, `USER`, `USING`, `VARIADIC`, `WHEN`, `WHERE`, `WINDOW`, `WITH`, `WITHIN`, `FALSE`, `TRUE`.

    Additionally, the following prefixes will be reserved: `DD_`, `DD.`, `XL_`,  and `XL.` 

5. The Datadocs SQL is eventually executed against a backend. This may be our DuckDB in-browser store, it may be our BigQuery remote persistent store, it may be our javascript expression evaluation, or it may be a remote database owned by a user. Regardless of what target engine it is executed on, we will need to do **some** sort of translation from the Datadocs SQL to that execution engine, some very close (DucKDB) others almost uselsss as a database unless the data is extracted (Redis, Neo4j, etc.). Even simple expression such as the following may have vastly different outcomes on different databases:

    | **SQL**             	| **OK**                                                	| **Invalid**                                                     	|
    |---------------------	|-------------------------------------------------------	|-----------------------------------------------------------------	|
    | `SELECT '1' + 2`     	| SQLServer, Oracle, MySQL, SQLite, Snowflake, Postgres 	| BigQuery, DuckDB, Excel                                         	|
    | `SELECT '1.1' + 2.2` 	| SQLServer, Oracle, MySQL, SQLite, Snowflake, Postgres 	| BigQuery, DuckDB, Excel                                         	|
    | `SELECT 1 + '2.2'`    	| Oracle, MySQL, SQLite, Snowflake                      	| BigQuery, DuckDB, Excel, SQLServer, Postgres,                   	|
    | `SELECT 1 + 'a'`      	| MySQL, SQLite                                         	| BigQuery, DuckDB, Excel, SQLServer, Oracle, Snowflake, Postgres 	|

    This means that if we execute `SELECT 1 + '1'` in BigQuery it will fail. In this case it is simple, we can of course reduce this to `2` and not even have to use BigQuery. Unfortunately, it's not that simple, as the following would not work on an `INT` column: `SELECT age + '1'`. Because of this we will enforce strict type checking, and for example, raise an error/warning on `1 + '1'` or any non-coercible types.


6. Not all functions will be preview-able. We should maintain a base level of metadata about functions (which will be extensible) to indicate such things as whether they are volatile or previewable. Here is an [example from Google Sheets](https://gyazo.com/d740ee2874e3852928e87bf542046111) of some functions that are not immediately previewable and others that are. We will use the `DD.TRANSLATE()` function as an example of a function we will not implement.

7. `VARIANT` values occur when dealing with storing and manipulating values that are either stored in a spreadsheet or stored as a `VARIANT` column by our database. However, since we will not yet be dealing with the `FROM` clause or retrieving existing values from a spreadsheet (or for that matter, storing resultant values from an expression) we can ignore them for now. They will be handled as a separate item.

<br/><br/>

## Future considerations: 

A user may define various functions, variables, and other helpers within the application. These User-Defined objects include:
 
1. **TYPE**: We may allow a user to create a new type. This would allow for the literal in the form of `<TYPE> <LITERAL>`, such as `SELECT PERSON ('John', 'Smith')`. This means we will store an array or similar object of additional types that are available to the current user.

2. **FUNCTION**: We may allow a user to create a Scalar UDF, which would allow for `<FUNCTION>(...)`, such as `addThree(1,2,3)`. This would also require an array or similar object of additional available functions for the grammar. We may also allow the addition of Scalar **Aggregate** Functions. While this is quite different from a programming perspective, in terms of parsing it is quite similar -- for example `ABS(...)` vs `SUM(...)`.

3. **VARIABLE**: Similar to a function, a user may define some variables that may be loaded into the environment, which would allow for doing something like `SELECT * FROM table WHERE city IN myCitiesArray`. Additionally, we may consider using something like [LiquidJS](https://liquidjs.com/), [similar to this](https://docs.getdbt.com/docs/building-a-dbt-project/jinja-macros), which would give additional power to variable usage. This would also require an array or similar object of additional variables for the grammar. Variables are non-trivial and need much time and thought in terms of namespace hierarchy: for example, a variable may belong to an Organization or User, such as `User.organization = "Google"`, or a variable may belong to a Workbook, Sheet, or Abstract Environment such as a Module that can be loaded by a user into a workspace or query editor **and** can be shared with other users (for example, a module containing various helper functions and variables).

4. **INTERFACE**: Perhaps most important of all, functions will eventually be able to make calls to the interface to receive data from it. This is similar to in Excel being able to reference a cell, range, or table by doing something like `=A1`. The general syntax of this will be similar to `DD_FROM_UI(objectID, Path)`, a full example of this might be something like `SELECT * FROM myTable WHERE Country = DD_FROM_UI('Wkbk5.Sheet1', 'A1')`. While this might seem complex and verbose for the end-user to write, the interface will be similar to Excel and they can basically just click an object and it will (1) create a friendly visual within the query editor; and (2) substitute the correct function call behind-the-scenes, such as: 

    ![SQL](https://i.stack.imgur.com/PQIN0.png)

    The value(s) will be fetched at runtime. Additionally, multiple objects within the interface -- and not just cells -- may contain data. An example of this might be a Filter Panel to retrieve Active filters.


5. **TABLE UDF**: We may allow a user to create a Table UDF. This is quite complex on the programming side, but for the parser it allows for a function call on the right-hand-side of the `FROM`, for example, `SELECT * FROM makeTable(x)` instead of `SELECT makeScalar(x)`. Note that this type of function is only relevant when table-objects are involved.

5. **~~CAST / COLLATION~~**: We will **not** support user-created `CAST` or `COLLATION` types. If a user needs to cast to a type they can of course write a function, such as `SELECT toType(exp)`.


<br/><br/>
